---
title: Conversations
description: Learn how to manage conversation history and threading with the Uno SDK.
---

The Uno SDK provides conversation management capabilities that allow you to maintain context across multiple interactions with LLMs. Conversations are organized into namespaces, contain threads, and support automatic summarization to manage long conversation histories.

## Overview

Conversation management in the Uno SDK enables:
- **Persistent History**: Save and load conversation history across sessions
- **Threading**: Organize messages into conversations and threads
- **Summarization**: Automatically summarize long conversations to stay within token limits
- **Namespace Isolation**: Organize conversations by namespace (e.g., user ID, session ID)

## Conversation Structure

Conversations follow a hierarchical structure:
- **Namespace**: Top-level container (e.g., user ID, session ID)
- **Conversation**: A collection of related threads
- **Thread**: A sequence of messages within a conversation
- **Message**: Individual user/assistant messages

## Creating a Conversation Manager

Use `NewConversationManager` to create a conversation manager instance:

```go
import (
    "github.com/google/uuid"
    "github.com/praveen001/uno/pkg/sdk"
)

client, err := sdk.New(&sdk.ClientOptions{
    Endpoint:    "http://localhost:6060",
    ProjectName: "my-project",
    VirtualKey:  "sk-amg-your-virtual-key",
})
if err != nil {
    panic(err)
}

// Create a conversation manager
namespace := "user-123"  // Unique identifier for the conversation namespace
messageID := uuid.NewString()  // Unique ID for this message/run
previousMessageID := ""  // Empty for new conversations, or the previous message ID for continuing

history := client.NewConversationManager(namespace, messageID, previousMessageID)
```

---

## Basic Usage

### Starting a New Conversation

When starting a new conversation, use an empty `previousMessageID`:

```go
import (
    "context"
    "github.com/google/uuid"
    "github.com/praveen001/uno/pkg/llm/responses"
    "github.com/praveen001/uno/pkg/sdk"
)

func main() {
    // ... client initialization ...

    // Start a new conversation
    history := client.NewConversationManager(
        "user-session-123",
        uuid.NewString(),
        "",  // Empty previousMessageID = new conversation
    )

    // Use with an agent
    agent := client.NewAgent(&agents.AgentOptions{
        Name:    "Chat Assistant",
        LLM:     model,
        History: history,
    })

    // Execute first message
    resp, err := agent.Execute(context.Background(), []responses.InputMessageUnion{
        responses.UserMessage("Hello!"),
    }, core.NilCallback)
    if err != nil {
        panic(err)
    }
}
```

### Continuing an Existing Conversation

To continue a conversation, pass the previous message ID:

```go
// First interaction
firstMessageID := uuid.NewString()
history1 := client.NewConversationManager("user-123", firstMessageID, "")

// ... execute first message ...

// Continue the conversation
secondMessageID := uuid.NewString()
history2 := client.NewConversationManager("user-123", secondMessageID, firstMessageID)

// The agent will now have access to the previous conversation context
```

---

## Conversation Options

### Specifying a Conversation ID

You can explicitly set a conversation ID to organize threads:

```go
import (
    "github.com/praveen001/uno/pkg/agent-framework/history"
)

history := client.NewConversationManager(
    "user-123",
    uuid.NewString(),
    "",
    history.WithConversationID("conversation-abc-123"),  // Explicit conversation ID
)
```

### Adding a Summarizer

Enable automatic summarization for long conversations:

```go
import (
    "github.com/praveen001/uno/pkg/agent-framework/history"
    "github.com/praveen001/uno/pkg/agent-framework/summariser"
)

// Create a summarizer (example: sliding window)
summarizer := summariser.NewSlidingWindowHistorySummarizer(&summariser.SlidingWindowHistorySummarizerOptions{
    KeepCount: 10,  // Keep last 10 messages
})

history := client.NewConversationManager(
    "user-123",
    uuid.NewString(),
    "",
    history.WithSummarizer(summarizer),
)
```

---

## Working with Conversation History

### Loading Previous Messages

The conversation manager automatically loads previous messages when used with an agent. Messages are loaded based on the `previousMessageID`:

```go
history := client.NewConversationManager(
    "user-123",
    uuid.NewString(),
    previousMessageID,  // Loads all messages up to this point
)

// Messages are automatically loaded when the agent executes
agent := client.NewAgent(&agents.AgentOptions{
    Name:    "Assistant",
    LLM:     model,
    History: history,
})

// The agent will have access to previous conversation context
resp, err := agent.Execute(ctx, []responses.InputMessageUnion{
    responses.UserMessage("What did we discuss earlier?"),
}, core.NilCallback)
```

### Saving Messages

Messages are automatically saved when you use the conversation manager with an agent. The agent framework handles saving after each execution:

```go
// The conversation manager automatically saves messages after agent execution
resp, err := agent.Execute(ctx, messages, callback)
// Messages are saved automatically here
```

---

## Multi-Turn Conversations

Here's a complete example of a multi-turn conversation:

```go
import (
    "context"
    "fmt"
    "github.com/google/uuid"
    "github.com/praveen001/uno/pkg/llm/responses"
    "github.com/praveen001/uno/pkg/sdk"
    "github.com/praveen001/uno/pkg/agent-framework/agents"
    "github.com/praveen001/uno/pkg/agent-framework/core"
)

func main() {
    client, _ := sdk.New(&sdk.ClientOptions{
        Endpoint:    "http://localhost:6060",
        ProjectName: "my-project",
        VirtualKey:  "sk-amg-key",
    })

    model := client.NewLLM(sdk.LLMOptions{
        Provider: llm.ProviderNameOpenAI,
        Model:    "gpt-4o",
    })

    namespace := "chat-session-123"
    var previousMessageID string

    // First turn
    msgID1 := uuid.NewString()
    history1 := client.NewConversationManager(namespace, msgID1, "")
    
    agent1 := client.NewAgent(&agents.AgentOptions{
        Name:    "Assistant",
        LLM:     model,
        History: history1,
    })

    resp1, _ := agent1.Execute(context.Background(), []responses.InputMessageUnion{
        responses.UserMessage("My name is Alice"),
    }, core.NilCallback)
    
    previousMessageID = msgID1
    fmt.Println("Response 1:", resp1)

    // Second turn - continues the conversation
    msgID2 := uuid.NewString()
    history2 := client.NewConversationManager(namespace, msgID2, previousMessageID)
    
    agent2 := client.NewAgent(&agents.AgentOptions{
        Name:    "Assistant",
        LLM:     model,
        History: history2,
    })

    resp2, _ := agent2.Execute(context.Background(), []responses.InputMessageUnion{
        responses.UserMessage("What's my name?"),
    }, core.NilCallback)
    
    // The agent remembers that the user's name is Alice
    fmt.Println("Response 2:", resp2)
}
```

---

## Namespace Organization

Namespaces allow you to organize conversations by user, session, or any other logical grouping:

```go
// Different users have separate conversation histories
user1History := client.NewConversationManager("user-alice", msgID, prevMsgID)
user2History := client.NewConversationManager("user-bob", msgID, prevMsgID)

// Sessions within the same user
session1History := client.NewConversationManager("user-alice-session-1", msgID, prevMsgID)
session2History := client.NewConversationManager("user-alice-session-2", msgID, prevMsgID)
```

---

## Best Practices

1. **Use Meaningful Namespaces**: Use namespaces that logically group conversations (e.g., user IDs, session IDs).

2. **Track Message IDs**: Keep track of message IDs to enable conversation continuation.

3. **Handle Errors**: Always handle errors when loading or saving conversation history.

4. **Use Summarization**: For long conversations, enable summarization to manage token limits.

5. **Namespace Isolation**: Ensure namespaces are unique and don't overlap between different logical groups.

---

## Advanced: Custom Conversation Persistence

The SDK uses external conversation persistence by default (via the agent server API). For custom implementations, you can create your own persistence adapter that implements the `ConversationPersistenceManager` interface.

---

## Limitations

- Conversation history is stored server-side and requires an active connection to the agent server.
- Message IDs must be unique within a namespace.
- Large conversation histories may require summarization to stay within model context limits.
