---
title: Conversation History
---

Conversation history enables agents to maintain context across multiple interactions. By preserving previous messages, agents can reference earlier exchanges and build upon prior context, facilitating natural, context-aware conversations.

## Overview

When a conversation history manager is provided to an agent, it performs the following operations:
- **Loads Previous Messages**: Automatically retrieves conversation history based on the previous message ID
- **Saves Automatically**: Persists new messages after each execution

## Enabling Conversation History

To enable conversation history, create an instance of `ConversationManager` with the following parameters:
- `namespace` - Identifies the conversation namespace for isolation
- `previousMessageId` - The message ID of the previous message used to fetch all preceding messages. For new conversations, this should be an empty string

Pass the created instance to the agent's `History` field.

### Example
```go
cm := client.NewConversationManager("projX/user1", "083a1ead-18a8-460e-9a38-3cfd9472260b")
agent := agents.NewAgent(&agents.AgentOptions{
    Name:        "Hello world agent",
    LLM:         model,
    History:     cm,
})
```

---

## Persistence

The conversation manager supports three persistence configurations for storing conversation history:

### 1. No Persistence

When the SDK client is initialized without `endpoint` and `projectName`, messages are not persisted by default. History remains available in-memory for the lifetime of the `ConversationManager` instance. As long as you use the same instance, the conversation history will be retained.

### 2. Uno Gateway Persistence

When the SDK client is initialized with `endpoint` and `projectName`, the conversation manager automatically persists messages to the Uno Gateway server.

### 3. Custom Persistence

To implement custom persistence, implement the `ConversationPersistenceManager` interface:

```go
type ConversationPersistenceManager interface {
	LoadMessages(ctx context.Context, namespace string, previousMessageID string) ([]conversation.ConversationMessage, error)
	SaveMessages(ctx context.Context, namespace, msgId, previousMsgId, conversationId string, messages []responses.InputMessageUnion, meta map[string]any) error
	SaveSummary(ctx context.Context, namespace string, summary conversation.Summary) error
}
```

Then pass your implementation to the conversation manager:

```go
cm := client.NewConversationManager("projX/user1", "083a1ead-18a8-460e-9a38-3cfd9472260b", history.WithPersistence(yourImpl))
```

## Complete Example

The following example demonstrates an agent with conversation history:

```go
// Create conversation manager
history := client.NewConversationManager("projX/user1", "083a1ead-18a8-460e-9a38-3cfd9472260b")

// Create agent with history
agent := client.NewAgent(&agents.AgentOptions{
    Name:        "Chat Assistant",
    Instruction: "You are a helpful assistant.",
    LLM:         client.NewLLM(sdk.LLMOptions{
        Provider: llm.ProviderNameOpenAI,
        Model:    "gpt-4o-mini",
    }),
    History:     history,
})

// First agent run
resp1, err := agent.Execute(context.Background(), []responses.InputMessageUnion{
    responses.UserMessage("My name is Alice"),
}, core.NilCallback)
if err != nil {
    log.Fatal(err)
}

fmt.Println("Response 1:", resp1[0].OfOutputMessage.Content[0].OfOutputText.Text)

agent2 := client.NewAgent(&agents.AgentOptions{
    Name:        "Chat Assistant",
    Instruction: "You are a helpful assistant.",
    LLM:         model,
    History:     history,
})

resp2, err := agent2.Execute(context.Background(), []responses.InputMessageUnion{
    responses.UserMessage("What's my name?"),
}, core.NilCallback)
if err != nil {
    log.Fatal(err)
}

// The agent remembers that the user's name is Alice
fmt.Println("Response 2:", resp2[0].OfOutputMessage.Content[0].OfOutputText.Text)
```