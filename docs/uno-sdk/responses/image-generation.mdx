---
title: Image Generation
description: Learn how to use image generation with the Uno SDK to generate images from text prompts.
---

The Uno SDK supports both image processing and image generation through LLMs that have the image capabilities. You can request images by including the image generation tool in your request, and the model will return generated images as base64-encoded data.

## Overview

Image generation allows you to create images from text descriptions. The model generates images and returns them as part of the response, which you can then decode and save or display.

## Enabling Image Generation

To enable image generation, include the `ImageGenerationTool` in your request's `Tools` array:

```go
import (
    "github.com/praveen001/uno/pkg/llm/responses"
    "github.com/praveen001/uno/internal/utils"
)

request := &responses.Request{
    Input: responses.InputUnion{
        OfString: utils.Ptr("Generate a beautiful sunset over mountains"),
    },
    Tools: []responses.ToolUnion{
        {
            OfImageGeneration: &responses.ImageGenerationTool{
                Type: "image_generation",
            },
        },
    },
}
```

---

## Handling Image Generation Responses

When the model generates an image, it returns an `ImageGenerationCallMessage` in the response output. This message contains the generated image as base64-encoded data.

### Example: Unary Image Generation

```go
import (
    "context"
    "encoding/base64"
    "fmt"
    "os"
    "github.com/praveen001/uno/pkg/llm/responses"
    "github.com/praveen001/uno/internal/utils"
)

func main() {
    // ... client and model initialization ...

    resp, err := model.NewResponses(context.Background(), &responses.Request{
        Input: responses.InputUnion{
            OfString: utils.Ptr("Create an image of a serene lake at sunset"),
        },
        Tools: []responses.ToolUnion{
            {
                OfImageGeneration: &responses.ImageGenerationTool{
                    Type: "image_generation",
                },
            },
        },
    })
    if err != nil {
        panic(err)
    }

    // Process the response
    for _, output := range resp.Output {
        if output.OfImageGenerationCall != nil {
            imgCall := output.OfImageGenerationCall
            
            fmt.Printf("Image ID: %s\n", imgCall.ID)
            fmt.Printf("Status: %s\n", imgCall.Status)
            fmt.Printf("Format: %s\n", imgCall.OutputFormat)
            fmt.Printf("Size: %s\n", imgCall.Size)
            fmt.Printf("Quality: %s\n", imgCall.Quality)
            
            // Decode and save the image
            if imgCall.Result != "" {
                imageData, err := base64.StdEncoding.DecodeString(imgCall.Result)
                if err != nil {
                    panic(err)
                }
                
                filename := fmt.Sprintf("generated_image.%s", imgCall.OutputFormat)
                if err := os.WriteFile(filename, imageData, 0644); err != nil {
                    panic(err)
                }
                
                fmt.Printf("Image saved to %s\n", filename)
            }
        }
    }
}
```

---

## Image Generation Message Structure

The `ImageGenerationCallMessage` contains the following fields:

| Field | Type | Description |
| :--- | :--- | :--- |
| **Type** | `string` | Always `"image_generation_call"` |
| **ID** | `string` | Unique identifier for the image (prefixed with `"ig_"`) |
| **Status** | `string` | Status of generation (e.g., `"generating"`, `"completed"`) |
| **Background** | `string` | Background type (e.g., `"opaque"`) |
| **OutputFormat** | `string` | Image format (e.g., `"png"`, `"jpeg"`) |
| **Quality** | `string` | Image quality (e.g., `"medium"`, `"high"`) |
| **Size** | `string` | Image dimensions (e.g., `"1024x1024"`) |
| **Result** | `string` | Base64-encoded image data |

---

## Streaming Image Generation

When streaming, image generation progress is reported through different chunk types:

- `image_generation_call.in_progress`: Generation has started
- `image_generation_call.generating`: Image is being generated
- `image_generation_call.partial_image`: Partial image data (if supported)

### Example: Streaming Image Generation

```go
import (
    "context"
    "encoding/base64"
    "fmt"
    "os"
    "github.com/praveen001/uno/pkg/llm/responses"
    "github.com/praveen001/uno/internal/utils"
)

func main() {
    // ... client and model initialization ...

    stream, err := model.NewStreamingResponses(context.Background(), &responses.Request{
        Input: responses.InputUnion{
            OfString: utils.Ptr("Generate a futuristic cityscape"),
        },
        Parameters: responses.Parameters{
            Stream: utils.Ptr(true),
        },
        Tools: []responses.ToolUnion{
            {
                OfImageGeneration: &responses.ImageGenerationTool{
                    Type: "image_generation",
                },
            },
        },
    })
    if err != nil {
        panic(err)
    }

    var imageResult *responses.ImageGenerationCallMessage

    for chunk := range stream {
        // Check for image generation progress
        if chunk.OfImageGenerationCallInProgress != nil {
            fmt.Println("Image generation started...")
        }
        
        if chunk.OfImageGenerationCallGenerating != nil {
            fmt.Println("Generating image...")
        }
        
        if chunk.OfImageGenerationCallPartialImage != nil {
            partial := chunk.OfImageGenerationCallPartialImage
            fmt.Printf("Received partial image chunk %d\n", partial.PartialImageIndex)
            
            // You can optionally decode and display partial images
            if partial.PartialImageBase64 != "" {
                // Handle partial image data if needed
            }
        }
        
        // Check for completed output items
        if chunk.ChunkType() == "response.output_item.done" {
            item := chunk.OfOutputItemDone.Item
            if item.Type == "image_generation_call" {
                // The image generation is complete
                // The full result will be in the final response
            }
        }
    }

    // After streaming completes, check the final response for the image
    // Note: You may need to collect chunks or check a final response object
    // depending on your SDK implementation
}
```

---

## Saving Generated Images

Here's a helper function to save generated images:

```go
import (
    "encoding/base64"
    "fmt"
    "os"
    "github.com/praveen001/uno/pkg/llm/responses"
)

func saveGeneratedImage(imgCall *responses.ImageGenerationCallMessage, filename string) error {
    if imgCall.Result == "" {
        return fmt.Errorf("no image data in result")
    }
    
    // Decode base64 image
    imageData, err := base64.StdEncoding.DecodeString(imgCall.Result)
    if err != nil {
        return fmt.Errorf("failed to decode base64: %w", err)
    }
    
    // Determine file extension from output format
    ext := imgCall.OutputFormat
    if ext == "" {
        ext = "png" // default
    }
    
    fullFilename := fmt.Sprintf("%s.%s", filename, ext)
    
    // Write to file
    if err := os.WriteFile(fullFilename, imageData, 0644); err != nil {
        return fmt.Errorf("failed to write file: %w", err)
    }
    
    fmt.Printf("Image saved to %s (size: %s, format: %s)\n", 
        fullFilename, imgCall.Size, imgCall.OutputFormat)
    
    return nil
}

// Usage
for _, output := range resp.Output {
    if output.OfImageGenerationCall != nil {
        if err := saveGeneratedImage(output.OfImageGenerationCall, "my_image"); err != nil {
            panic(err)
        }
    }
}
```

---

## Image Generation Parameters

The model controls image generation parameters like size, quality, and format. These are typically set by the model based on its capabilities, but you can influence them through your prompt:

```go
request := &responses.Request{
    Input: responses.InputUnion{
        OfString: utils.Ptr("Generate a high-quality 1024x1024 PNG image of a mountain landscape"),
    },
    Tools: []responses.ToolUnion{
        {
            OfImageGeneration: &responses.ImageGenerationTool{
                Type: "image_generation",
            },
        },
    },
}
```

---

## Best Practices

1. **Be Descriptive**: Provide detailed descriptions in your prompts to get better results.

2. **Handle Errors**: Always check the `Status` field to ensure generation completed successfully.

3. **Validate Base64**: Verify that the `Result` field contains valid base64 data before decoding.

4. **Check Format**: Use the `OutputFormat` field to determine the correct file extension when saving.

5. **Streaming Considerations**: When streaming, wait for completion before accessing the full image data.

---

## Limitations

- Image generation support varies by provider and model. Not all models support image generation.
- Generated images are returned as base64-encoded strings, which can be memory-intensive for large images.
- Image quality, size, and format are typically controlled by the model and may not be directly configurable.
- Some providers may have rate limits or usage restrictions on image generation.

---

## Provider Compatibility

Image generation is supported by models that have this capability. Check your provider's documentation for:
- Which models support image generation
- Supported image formats and sizes
- Quality options available
- Rate limits and pricing

